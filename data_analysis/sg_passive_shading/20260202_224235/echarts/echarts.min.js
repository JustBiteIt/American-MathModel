(function(){
  function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
  function init(dom){
    const canvas = document.createElement("canvas");
    const rect = dom.getBoundingClientRect();
    const w = Math.max(320, rect.width || dom.clientWidth || 900);
    const h = Math.max(240, rect.height || dom.clientHeight || 620);
    canvas.width = w;
    canvas.height = h;
    dom.innerHTML = "";
    dom.appendChild(canvas);
    const ctx = canvas.getContext("2d");
    let option = null;
    function setOption(opt){ option = opt || {}; render(); }
    function render(){
      if(!option) return;
      const grid = option.grid || {};
      const left = grid.left || 70;
      const right = grid.right || 70;
      const top = grid.top || 60;
      const bottom = grid.bottom || 70;
      const plotW = w - left - right;
      const plotH = h - top - bottom;
      ctx.clearRect(0,0,w,h);
      ctx.fillStyle = "#fff";
      ctx.fillRect(0,0,w,h);

      const series = option.series || [];
      let xs = [], ys = [];
      series.forEach(s => {
        (s.data || []).forEach(p => {
          if(p && p.length >= 2 && isFinite(p[0]) && isFinite(p[1])){
            xs.push(p[0]); ys.push(p[1]);
          }
        });
      });
      let xmin = Math.min.apply(null, xs);
      let xmax = Math.max.apply(null, xs);
      let ymin = Math.min.apply(null, ys);
      let ymax = Math.max.apply(null, ys);
      if(!isFinite(xmin) || !isFinite(xmax)){ xmin = 0; xmax = 1; }
      if(!isFinite(ymin) || !isFinite(ymax)){ ymin = 0; ymax = 1; }
      if(xmax - xmin < 1e-9){ xmax = xmin + 1; }
      if(ymax - ymin < 1e-9){ ymax = ymin + 1; }

      function xScale(x){ return left + (x - xmin) / (xmax - xmin) * plotW; }
      function yScale(y){ return top + plotH - (y - ymin) / (ymax - ymin) * plotH; }

      // axes
      ctx.strokeStyle = "#222";
      ctx.lineWidth = 1;
      ctx.beginPath();
      ctx.moveTo(left, top);
      ctx.lineTo(left, top + plotH);
      ctx.lineTo(left + plotW, top + plotH);
      ctx.stroke();

      // ticks
      ctx.fillStyle = "#222";
      ctx.font = "12px Arial, sans-serif";
      const nt = 5;
      for(let i=0;i<=nt;i++){
        const tx = left + plotW * i / nt;
        const vx = xmin + (xmax - xmin) * i / nt;
        ctx.strokeStyle = "#ddd";
        ctx.beginPath();
        ctx.moveTo(tx, top);
        ctx.lineTo(tx, top + plotH);
        ctx.stroke();
        ctx.fillStyle = "#222";
        ctx.fillText(vx.toFixed(0), tx - 10, top + plotH + 18);
      }
      for(let i=0;i<=nt;i++){
        const ty = top + plotH - plotH * i / nt;
        const vy = ymin + (ymax - ymin) * i / nt;
        ctx.strokeStyle = "#ddd";
        ctx.beginPath();
        ctx.moveTo(left, ty);
        ctx.lineTo(left + plotW, ty);
        ctx.stroke();
        ctx.fillStyle = "#222";
        ctx.fillText(vy.toFixed(2), left - 50, ty + 4);
      }

      // axis labels
      if(option.xAxis && option.xAxis.name){
        ctx.fillText(option.xAxis.name, left + plotW/2 - 110, h - 10);
      }
      if(option.yAxis && option.yAxis.name){
        ctx.save();
        ctx.translate(16, top + plotH/2 + 60);
        ctx.rotate(-Math.PI/2);
        ctx.fillText(option.yAxis.name, 0, 0);
        ctx.restore();
      }

      // series points / lines
      const colors = ["#3b82f6", "#ef4444", "#10b981", "#f59e0b", "#111827"];
      series.forEach((s, idx) => {
        const col = colors[idx % colors.length];
        const size = s.symbolSize || 3;
        const opacity = (s.itemStyle && s.itemStyle.opacity != null) ? s.itemStyle.opacity : 0.7;
        const data = s.data || [];
        if(s.type === "line"){
          ctx.strokeStyle = col;
          ctx.lineWidth = (s.lineStyle && s.lineStyle.width) ? s.lineStyle.width : 2;
          ctx.beginPath();
          let started = false;
          data.forEach(p => {
            if(!p || p.length < 2) return;
            const x = xScale(p[0]);
            const y = yScale(p[1]);
            if(!started){ ctx.moveTo(x, y); started = true; }
            else { ctx.lineTo(x, y); }
          });
          ctx.stroke();
        }
        ctx.fillStyle = col;
        ctx.globalAlpha = clamp(opacity, 0.05, 1.0);
        data.forEach(p => {
          if(!p || p.length < 2) return;
          const x = xScale(p[0]);
          const y = yScale(p[1]);
          ctx.beginPath();
          ctx.arc(x, y, size, 0, Math.PI * 2);
          ctx.fill();
        });
        ctx.globalAlpha = 1.0;
      });
    }
    function getDataURL(){ return canvas.toDataURL("image/png"); }
    function resize(){
      const r = dom.getBoundingClientRect();
      const nw = Math.max(320, r.width || dom.clientWidth || 900);
      const nh = Math.max(240, r.height || dom.clientHeight || 620);
      canvas.width = nw; canvas.height = nh;
      render();
    }
    return { setOption, getDataURL, resize };
  }
  window.echarts = { init: init };
})();